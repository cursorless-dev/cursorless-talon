from typing import Any
from contextlib import suppress

from ..compound_targets import is_active_included, is_anchor_included

<<<<<<< HEAD
first_modifiers = {"first": "first"}
last_modifiers = {"last": "last"}

mod = Module()

mod.list("cursorless_first_modifier", desc="Cursorless first modifiers")
mod.list("cursorless_last_modifier", desc="Cursorless last modifiers")


@mod.capture(
    rule="<user.ordinals_small> | [<user.ordinals_small>] {user.cursorless_last_modifier}"
)
def ordinal_or_last(m) -> int:
    """An ordinal or the word 'last'"""
    if m[-1] == "last":
        return -getattr(m, "ordinals_small", 1)
    return m.ordinals_small - 1
=======
def ordinal_or_last(m) -> int:
    """An ordinal or the word 'last'"""
    if m["_node"].words()[0] == "last":
        return -1
    return m["ordinals_small"] - 1
>>>>>>> 7795fec... initial update to caster

def cursorless_ordinal_range(m) -> dict[str, Any]:
    """Ordinal range"""
<<<<<<< HEAD
    anchor = create_ordinal_scope_modifier(
        m.cursorless_scope_type, m.ordinal_or_last_list[0]
    )
    if len(m.ordinal_or_last_list) > 1:
=======
    ordinal_or_last_list = [m["ordinal_or_last1"]]
    with suppress(KeyError):
        ordinal_or_last_list.append(m["ordinal_or_last2"])

    if len(ordinal_or_last_list) > 1:
        range_connective = m["range_connective"]
        include_anchor = is_anchor_included(range_connective)
        include_active = is_active_included(range_connective)
        anchor = create_ordinal_scope_modifier(
            m["scope_type"], ordinal_or_last_list[0]
        )
>>>>>>> 7795fec... initial update to caster
        active = create_ordinal_scope_modifier(
            m["scope_type"], ordinal_or_last_list[1]
        )
        include_anchor = is_anchor_included(m.cursorless_range_connective)
        include_active = is_active_included(m.cursorless_range_connective)
        return {
            "type": "range",
            "anchor": anchor,
            "active": active,
            "excludeAnchor": not include_anchor,
            "excludeActive": not include_active,
        }
<<<<<<< HEAD
    return anchor


@mod.capture(
    rule="({user.cursorless_first_modifier} | {user.cursorless_last_modifier}) <user.private_cursorless_number_small> <user.cursorless_scope_type_plural>"
)
def cursorless_first_last(m) -> dict[str, Any]:
    """First/last `n` scopes; eg "first three funks"""
    if m[0] == "first":
        return create_ordinal_scope_modifier(
            m.cursorless_scope_type_plural, 0, m.private_cursorless_number_small
        )
    return create_ordinal_scope_modifier(
        m.cursorless_scope_type_plural,
        -m.private_cursorless_number_small,
        m.private_cursorless_number_small,
    )


@mod.capture(rule="<user.cursorless_ordinal_range> | <user.cursorless_first_last>")
def cursorless_ordinal_scope(m) -> dict[str, Any]:
    """Ordinal ranges such as subwords or characters"""
    return m[0]


def create_ordinal_scope_modifier(scope_type: dict, start: int, length: int = 1):
=======
    else:
        return create_ordinal_scope_modifier(
            m["scope_type"], ordinal_or_last_list[0]
        )

def cursorless_first_last(m) -> dict[str, Any]:
    """First/last `n` scopes; eg "first three funk"""
    if m["_node"].words()[0] == "first":
        return create_ordinal_scope_modifier(
            m["scope_type"], 0, m["number_small"]
        )
    return create_ordinal_scope_modifier(
        m["scope_type"], -m["number_small"], m["number_small"]
    )

def create_ordinal_scope_modifier(scope_type: Any, start: int, length: int = 1):
>>>>>>> 7795fec... initial update to caster
    return {
        "type": "ordinalScope",
        "scopeType": scope_type,
        "start": start,
        "length": length,
    }
